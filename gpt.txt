package gtml

import (
	"fmt"
	"slices"
	"strings"

	"github.com/PuerkitoBio/goquery"
	"github.com/phillip-england/fungi"
	"github.com/phillip-england/gqpp"
)

// ##==================================================================
const (
	KeyElementComponent = "_component"
	KeyElementFor       = "_for"
)

// ##==================================================================
type Element interface {
	GetSelection() *goquery.Selection
	GetParam() (string, error)
	GetHtml() string
	Print()
	GetType() string
	GetAttr() string
	GetAttrParts() []string
	GetProps() []Prop
}

func GetFullElementList() []string {
	childElements := GetChildElementList()
	full := append(childElements, KeyElementComponent)
	return full
}

func GetChildElementList() []string {
	return []string{KeyElementFor}
}
func NewElement(sel *goquery.Selection) (Element, error) {
	match := gqpp.GetFirstMatchingAttr(sel, GetFullElementList()...)
	switch match {
	case KeyElementComponent:
		elm, err := NewElementComponent(sel)
		if err != nil {
			return nil, err
		}
		return elm, nil
	case KeyElementFor:
		elm, err := NewElementFor(sel)
		if err != nil {
			return nil, err
		}
		return elm, nil
	}
	htmlStr, err := gqpp.NewHtmlFromSelection(sel)
	if err != nil {
		return nil, err
	}
	return nil, fmt.Errorf("provided selection is not a valid element: %s", htmlStr)
}

func WalkElementChildren(elm Element, fn func(child Element) error) error {
	var potErr error
	elm.GetSelection().Find("*").Each(func(i int, inner *goquery.Selection) {
		child, err := NewElement(inner)
		if err != nil {
			// skip elements which are not a valid Element
		} else {
			err = fn(child)
			if err != nil {
				potErr = err
				return
			}
		}
	})
	if potErr != nil {
		return potErr
	}
	return nil
}

func GetElementParams(elm Element) (string, error) {
	elementSpecificParams := make([]string, 0)
	err := WalkElementChildren(elm, func(child Element) error {
		param, err := child.GetParam()
		if err != nil {
			return err
		}
		if !slices.Contains(elementSpecificParams, param) && param != "" {
			elementSpecificParams = append(elementSpecificParams, param)
		}
		return nil
	})
	if err != nil {
		return "", err
	}
	strParams := make([]string, 0)
	for _, prop := range elm.GetProps() {
		strProp := prop.GetValue() + " " + "string"
		if !slices.Contains(strParams, strProp) && strings.Count(strProp, ".") == 0 {
			strParams = append(strParams, strProp)
		}
	}
	paramSlice := append(strParams, elementSpecificParams...)
	params := strings.Join(paramSlice, ", ")
	return params, nil
}

func WalkElementDirectChildren(elm Element, fn func(child Element) error) error {
	err := WalkElementChildren(elm, func(child Element) error {
		if !gqpp.HasParentWithAttrs(child.GetSelection(), elm.GetSelection(), GetChildElementList()...) {
			err := fn(child)
			if err != nil {
				return err
			}
		}
		return nil
	})
	if err != nil {
		return err
	}
	return nil
}

func GetElementAsBuilderSeries(elm Element, builderName string) (string, error) {
	htmlStr := elm.GetHtml()
	calls := ""
	err := WalkElementChildren(elm, func(child Element) error {
		childHtml := child.GetHtml()
		if childHtml == "" {
			return nil
		}
		goVar, err := NewGoVar(child)
		if err != nil {
			return err
		}
		call := fmt.Sprintf("%s.WriteString(%s)", builderName, goVar.GetVarName())
		calls += call + "\n"
		htmlStr = strings.Replace(htmlStr, childHtml, call, 1)
		return nil
	})
	if err != nil {
		return "", err
	}
	for _, prop := range elm.GetProps() {
		call := PropAsWriteString(prop, builderName)
		htmlStr = strings.Replace(htmlStr, prop.GetRaw(), call, 1)
	}
	finalCalls := ""
	for {
		index := strings.Index(htmlStr, builderName)
		if index == -1 {
			break
		}
		part := htmlStr[:index]
		if part != "" && part != " " {
			finalCalls += fmt.Sprintf("%s.WriteString(`%s`)\n", builderName, part)
			htmlStr = strings.Replace(htmlStr, part, "", 1)
		}
		index = strings.Index(htmlStr, ")")
		if index == -1 {
			break
		}
		part = htmlStr[:index+1]
		if part != "" && part != " " {
			finalCalls += part + "\n"
			htmlStr = strings.Replace(htmlStr, part, "", 1)
		}
	}
	finalCalls += fmt.Sprintf("%s.WriteString(`%s`)\n", builderName, htmlStr)
	return finalCalls, nil
}

func RemoveElementChildren(elm Element) (Element, error) {
	elmHtml := elm.GetHtml()
	err := WalkElementDirectChildren(elm, func(child Element) error {
		childHtml := child.GetHtml()
		elmHtml = strings.Replace(elmHtml, childHtml, "", 1)
		return nil
	})
	if err != nil {
		return nil, err
	}
	newSel, err := gqpp.NewSelectionFromStr(elmHtml)
	if err != nil {
		return nil, err
	}
	newElm, err := NewElement(newSel)
	if err != nil {
		return nil, err
	}
	return newElm, nil
}

// ##==================================================================
type ElementComponent struct {
	Selection *goquery.Selection
	Html      string
	Type      string
	Attr      string
	AttrParts []string
	Name      string
	Props     []Prop
}

func NewElementComponent(sel *goquery.Selection) (*ElementComponent, error) {
	htmlStr, err := gqpp.NewHtmlFromSelection(sel)
	if err != nil {
		return nil, err
	}
	attr, err := gqpp.ForceElementAttr(sel, KeyElementComponent)
	if err != nil {
		return nil, err
	}
	parts, err := gqpp.ForceElementAttrParts(sel, KeyElementComponent, 1)
	if err != nil {
		return nil, err
	}
	elm := &ElementComponent{
		Selection: sel,
		Html:      htmlStr,
		Type:      KeyElementComponent,
		Attr:      attr,
		AttrParts: parts,
	}
	elm.Name = fmt.Sprintf("%s:%s", elm.GetType(), elm.GetAttr())
	props, err := NewProps(elm)
	if err != nil {
		return nil, err
	}
	elm.Props = props
	return elm, nil
}

func (elm *ElementComponent) GetSelection() *goquery.Selection { return elm.Selection }
func (elm *ElementComponent) GetParam() (string, error)        { return "", nil }
func (elm *ElementComponent) GetHtml() string                  { return elm.Html }
func (elm *ElementComponent) Print()                           { fmt.Println(elm.Html) }
func (elm *ElementComponent) GetType() string                  { return elm.Type }
func (elm *ElementComponent) GetAttr() string                  { return elm.Attr }
func (elm *ElementComponent) GetAttrParts() []string           { return elm.AttrParts }
func (elm *ElementComponent) GetName() string                  { return elm.Name }
func (elm *ElementComponent) GetProps() []Prop                 { return elm.Props }

// ##==================================================================
type ElementFor struct {
	Selection *goquery.Selection
	Html      string
	Type      string
	Attr      string
	AttrParts []string
	Name      string
	Props     []Prop
}

func NewElementFor(sel *goquery.Selection) (*ElementFor, error) {
	elm := &ElementFor{}
	err := fungi.Process(
		func() error { return elm.initSelection(sel) },
		func() error { return elm.initType() },
		func() error { return elm.initHtml() },
		func() error { return elm.initAttr() },
		func() error { return elm.initName() },
	)
	props, err := NewProps(elm)
	if err != nil {
		return nil, err
	}
	elm.Props = props
	return elm, nil
}

func (elm *ElementFor) GetSelection() *goquery.Selection { return elm.Selection }
func (elm *ElementFor) GetParam() (string, error) {
	parts, err := gqpp.ForceElementAttrParts(elm.GetSelection(), KeyElementFor, 4)
	if err != nil {
		return "", err
	}
	iterItems := parts[2]
	if strings.Contains(iterItems, ".") {
		return "", nil
	}
	iterType := parts[3]
	return iterItems + " " + iterType, nil
}
func (elm *ElementFor) GetHtml() string        { return elm.Html }
func (elm *ElementFor) Print()                 { fmt.Println(elm.Html) }
func (elm *ElementFor) GetType() string        { return elm.Type }
func (elm *ElementFor) GetAttr() string        { return elm.Attr }
func (elm *ElementFor) GetAttrParts() []string { return elm.AttrParts }
func (elm *ElementFor) GetName() string        { return elm.Name }
func (elm *ElementFor) GetProps() []Prop       { return elm.Props }

func (elm *ElementFor) initSelection(sel *goquery.Selection) error {
	elm.Selection = sel
	return nil
}

func (elm *ElementFor) initType() error {
	elm.Type = KeyElementFor
	return nil
}

func (elm *ElementFor) initHtml() error {
	htmlStr, err := gqpp.NewHtmlFromSelection(elm.GetSelection())
	if err != nil {
		return err
	}
	elm.Html = htmlStr
	return nil
}

func (elm *ElementFor) initAttr() error {
	attr, err := gqpp.ForceElementAttr(elm.GetSelection(), KeyElementFor)
	if err != nil {
		return err
	}
	parts, err := gqpp.ForceElementAttrParts(elm.GetSelection(), KeyElementFor, 4)
	if err != nil {
		return err
	}
	elm.Attr = attr
	elm.AttrParts = parts
	return nil
}

func (elm *ElementFor) initName() error {
	elm.Name = fmt.Sprintf("%s:%s", elm.GetType(), elm.GetAttr())
	return nil
}
package gtml

import (
	"fmt"

	"github.com/phillip-england/fungi"
	"github.com/phillip-england/gqpp"

	"github.com/phillip-england/purse"
)

// ##==================================================================
type Func interface {
	GetData() string
	SetData(str string)
	GetVars() []Var
}

func NewFunc(elm Element) (Func, error) {
	if elm.GetType() == KeyElementComponent {
		fn, err := NewGoComponentFunc(elm)
		if err != nil {
			return nil, err
		}
		return fn, nil
	}
	return nil, fmt.Errorf("provided element does not corrospond to a valid GoFunc: %s", elm.GetHtml())
}

func PrintGoFunc(fn Func) {
	fmt.Println(fn.GetData())
}

// ##==================================================================
type GoComponentFunc struct {
	Element  Element
	Vars     []Var
	Data     string
	VarStr   string
	Name     string
	ParamStr string
}

func NewGoComponentFunc(elm Element) (*GoComponentFunc, error) {
	fn := &GoComponentFunc{
		Element: elm,
	}
	err := fungi.Process(
		func() error { return fn.initName() },
		func() error { return fn.initVars() },
		func() error { return fn.initVarStr() },
		func() error { return fn.initParamStr() },
		func() error { return fn.initData() },
	)
	if err != nil {
		return nil, err
	}
	return fn, nil
}

func (fn *GoComponentFunc) GetData() string    { return fn.Data }
func (fn *GoComponentFunc) SetData(str string) { fn.Data = str }
func (fn *GoComponentFunc) GetVars() []Var     { return fn.Vars }

func (fn *GoComponentFunc) initName() error {
	compAttr, err := gqpp.ForceElementAttr(fn.Element.GetSelection(), KeyElementComponent)
	if err != nil {
		return err
	}
	fn.Name = compAttr
	return nil
}

func (fn *GoComponentFunc) initVars() error {
	err := WalkElementDirectChildren(fn.Element, func(child Element) error {
		goVar, err := NewGoVar(child)
		if err != nil {
			return err
		}
		fn.Vars = append(fn.Vars, goVar)
		return nil
	})
	if err != nil {
		return err
	}
	return nil
}

func (fn *GoComponentFunc) initVarStr() error {
	str := ""
	for _, v := range fn.Vars {
		data := v.GetData()
		str += data + "\n"
	}
	str = purse.PrefixLines(str, "\t")
	fn.VarStr = str
	return nil
}

func (fn *GoComponentFunc) initParamStr() error {
	params, err := GetElementParams(fn.Element)
	if err != nil {
		return err
	}
	fn.ParamStr = params
	return nil
}

func (fn *GoComponentFunc) initData() error {
	series, err := GetElementAsBuilderSeries(fn.Element, "builder")
	if err != nil {
		return err
	}
	series = purse.PrefixLines(series, "\t")
	data := purse.RemoveFirstLine(fmt.Sprintf(`
func %s(%s) string {
	var builder strings.Builder
%s
%s
	return builder.String()
}
	`, fn.Name, fn.ParamStr, fn.VarStr, series))
	data = purse.RemoveEmptyLines(data)
	fn.Data = data
	return nil
}
package gtml

import (
	"fmt"
	"strings"

	"github.com/phillip-england/purse"
)

// ##==================================================================
const (
	KeyPropForType = "FORTYPE"
	KeyPropForStr  = "FORSTR"
	KeyPropStr     = "STR"
)

// ##==================================================================
type Prop interface {
	GetRaw() string
	GetValue() string
	GetType() string
	Print()
}

func NewProps(elm Element) ([]Prop, error) {
	props := make([]Prop, 0)
	// elements must only reference props within themselves, not OTHER elements, so we must remove all other child elements
	strProps := purse.ScanBetweenSubStrs(elm.GetHtml(), "{{", "}}")
	for _, prop := range strProps {
		val := purse.Squeeze(prop)
		val = purse.RemoveAllSubStr(val, "{{", "}}")
		if val == "" {
			return nil, fmt.Errorf("empty prop tag provided: %s", elm.GetHtml())
		}
		if strings.Count(val, ".") == 1 && len(strings.Split(val, ".")) == 2 {
			propForType, err := NewPropForType(prop, val)
			if err != nil {
				return nil, err
			}
			props = append(props, propForType)
			continue
		}
		propStr, err := NewPropStr(prop, val)
		if err != nil {
			return nil, err
		}
		props = append(props, propStr)
	}
	morphed := make([]Prop, 0)
	for _, prop := range props {
		if prop.GetType() == KeyPropStr {
			// check if an Element's children are _for
			err := WalkElementChildren(elm, func(child Element) error {
				if child.GetType() == KeyElementFor {
					attrParts := child.GetAttrParts()
					iterItem := attrParts[0]
					// if a for element of _for="item of items []string" exists, and a StrProp has the value of "item", then it is a ForStrProp
					if prop.GetValue() == iterItem {
						forStrProp, err := NewPropForStr(prop.GetRaw(), prop.GetValue())
						if err != nil {
							return err
						}
						morphed = append(morphed, forStrProp)
						return nil
					}
					morphed = append(morphed, prop)
				}
				return nil
			})
			if err != nil {
				return nil, err
			}
			continue
		}
		morphed = append(morphed, prop)
	}
	return morphed, nil
}

func PropAsWriteString(prop Prop, builderName string) string {
	return fmt.Sprintf("%s.WriteString(%s)", builderName, prop.GetValue())
}

// ##==================================================================
type PropForType struct {
	Raw   string
	Value string
	Type  string
}

func NewPropForType(raw string, val string) (*PropForType, error) {
	prop := &PropForType{
		Raw:   raw,
		Value: val,
		Type:  KeyPropForType,
	}
	return prop, nil
}

func (prop *PropForType) GetRaw() string   { return prop.Raw }
func (prop *PropForType) GetValue() string { return prop.Value }
func (prop *PropForType) GetType() string  { return prop.Type }
func (prop *PropForType) Print() {
	fmt.Println(fmt.Sprintf("raw: %s\nvalue: %s", prop.Raw, prop.Value))
}

// ##==================================================================
type PropForStr struct {
	Raw   string
	Value string
	Type  string
}

func NewPropForStr(raw string, val string) (*PropForStr, error) {
	prop := &PropForStr{
		Raw:   raw,
		Value: val,
		Type:  KeyPropForStr,
	}
	return prop, nil
}

func (prop *PropForStr) GetRaw() string   { return prop.Raw }
func (prop *PropForStr) GetValue() string { return prop.Value }
func (prop *PropForStr) GetType() string  { return prop.Type }
func (prop *PropForStr) Print() {
	fmt.Println(fmt.Sprintf("raw: %s\nvalue: %s", prop.Raw, prop.Value))
}

// ##==================================================================
type PropStr struct {
	Raw   string
	Value string
	Type  string
}

func NewPropStr(raw string, val string) (*PropStr, error) {
	prop := &PropStr{
		Raw:   raw,
		Value: val,
		Type:  KeyPropStr,
	}
	return prop, nil
}

func (prop *PropStr) GetRaw() string   { return prop.Raw }
func (prop *PropStr) GetValue() string { return prop.Value }
func (prop *PropStr) GetType() string  { return prop.Type }
func (prop *PropStr) Print() {
	fmt.Println(fmt.Sprintf("raw: %s\nvalue: %s", prop.Raw, prop.Value))
}

// ##==================================================================

// ##==================================================================

// ##==================================================================

// ##==================================================================

// ##==================================================================

// ##==================================================================
package gtml

import (
	"fmt"
	"go/format"

	"github.com/phillip-england/fungi"
	"github.com/phillip-england/gqpp"
	"github.com/phillip-england/purse"
)

// ##==================================================================
type Var interface {
	GetData() string
	GetVarName() string
}

func NewGoVar(elm Element) (Var, error) {
	switch elm.GetType() {
	case KeyElementFor:
		v, err := NewVarGoLoop(elm)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
	return nil, fmt.Errorf("element does not corrospond to a valid GoVar: %s", elm.GetHtml())
}

// ##==================================================================
type VarGoLoop struct {
	Element     Element
	VarName     string
	BuilderName string
	Vars        []Var
	WriteVarsAs string
	Data        string
	IterItems   string
	IterItem    string
	IterType    string
}

func NewVarGoLoop(elm Element) (*VarGoLoop, error) {
	v := &VarGoLoop{
		Element: elm,
	}
	err := fungi.Process(
		func() error { return v.initBasicInfo() },
		func() error { return v.initVars() },
		func() error { return v.initWriteVarsAs() },
		func() error { return v.initData() },
	)
	if err != nil {
		return nil, err
	}
	return v, nil
}

func (v *VarGoLoop) GetData() string    { return v.Data }
func (v *VarGoLoop) GetVarName() string { return v.VarName }

func (v *VarGoLoop) initVarName() error {
	v.VarName = v.Element.GetAttrParts()[0]
	return nil
}

func (v *VarGoLoop) initBasicInfo() error {
	attrParts, err := gqpp.ForceElementAttrParts(v.Element.GetSelection(), "_for", 4)
	if err != nil {
		return err
	}
	v.VarName = attrParts[0] + "Loop"
	v.BuilderName = attrParts[0] + "Builder"
	v.IterItems = attrParts[2]
	v.IterItem = attrParts[0]
	v.IterType = purse.RemoveAllSubStr(attrParts[3], "[]")
	return nil
}

func (v *VarGoLoop) initVars() error {
	err := WalkElementDirectChildren(v.Element, func(child Element) error {
		innerVar, err := NewGoVar(child)
		if err != nil {
			return nil
		}
		v.Vars = append(v.Vars, innerVar)
		return nil
	})
	if err != nil {
		return err
	}
	return nil
}

func (v *VarGoLoop) initWriteVarsAs() error {
	varsToWrite := ""
	for _, inner := range v.Vars {
		varsToWrite += "\t" + inner.GetData()
	}
	v.WriteVarsAs = varsToWrite
	return nil
}

func (v *VarGoLoop) initData() error {
	htmlStr, err := GetElementAsBuilderSeries(v.Element, v.BuilderName)
	if err != nil {
		return err
	}
	v.Data = purse.RemoveFirstLine(fmt.Sprintf(`
%s := collect(%s, func(i int, %s %s) string {
	var %s strings.Builder
%s
%s
	return %s.String()
})`, v.VarName, v.IterItems, v.IterItem, v.IterType, v.BuilderName, v.WriteVarsAs, htmlStr, v.BuilderName))
	code, err := format.Source([]byte(v.Data))
	if err != nil {
		return err
	}
	v.Data = string(code)
	v.Data = purse.RemoveEmptyLines(v.Data)
	return nil
}

package gtml

import (
	"fmt"
	"strconv"
	"strings"

	"github.com/phillip-england/purse"
)

// ##==================================================================
const (
	KeyAttrPlaceholder = "ATTRPLACEHOLDER"
	KeyAttrEmpty       = "ATTREMPTY"
	KeyAttrInt         = "ATTRINT"
	KeyAttrBool        = "ATTRBOOL"
	KeyAttrStr         = "ATTRSTR"
	KeyAttrAtParam     = "ATTRATPARAM"
)

// ##==================================================================
type Attr interface {
	Print()
	GetKey() string
	GetValue() string
	GetKeyValuePair() (string, string)
	GetType() string
}

func NewAttr(key string, value string) (Attr, error) {
	if value == "" {
		attr, err := NewAttrEmpty(key, value)
		if err != nil {
			return nil, err
		}
		return attr, nil
	}
	sqValue := purse.Squeeze(value)
	firstChar := string(sqValue[0])
	if firstChar == "@" {
		attr, err := NewAttrAtParam(key, value)
		if err != nil {
			return nil, err
		}
		return attr, nil
	}
	if strings.HasPrefix(sqValue, "{{") && strings.HasSuffix(sqValue, "}}") {
		attr, err := NewAttrPlaceholder(key, value)
		if err != nil {
			return nil, err
		}
		return attr, nil
	}
	if sqValue == "true" || sqValue == "false" {
		attr, err := NewAttrBool(key, value)
		if err != nil {
			return nil, err
		}
		return attr, nil
	}
	_, err := strconv.Atoi(sqValue)
	// if the attr can be converted to an int
	if err == nil {
		attr, err := NewAttrInt(key, value)
		if err != nil {
			return nil, err
		}
		return attr, nil
	}
	attr, err := NewAttrStr(key, value)
	if err != nil {
		return nil, err
	}
	return attr, nil
}

// ##==================================================================
type AttrPlaceholder struct {
	Key   string
	Value string
	Type  string
}

func NewAttrPlaceholder(key string, value string) (*AttrPlaceholder, error) {
	attr := &AttrPlaceholder{
		Key:   key,
		Value: value,
		Type:  KeyAttrPlaceholder,
	}
	return attr, nil
}

func (attr *AttrPlaceholder) Print()                            { fmt.Println(attr.Key + ":" + attr.Value) }
func (attr *AttrPlaceholder) GetKey() string                    { return attr.Key }
func (attr *AttrPlaceholder) GetValue() string                  { return attr.Value }
func (attr *AttrPlaceholder) GetKeyValuePair() (string, string) { return attr.Key, attr.Value }
func (attr *AttrPlaceholder) GetType() string                   { return attr.Type }

// ##==================================================================
type AttrEmpty struct {
	Key   string
	Value string
	Type  string
}

func NewAttrEmpty(key string, value string) (*AttrEmpty, error) {
	attr := &AttrEmpty{
		Key:   key,
		Value: value,
		Type:  KeyAttrEmpty,
	}
	return attr, nil
}

func (attr *AttrEmpty) Print()                            { fmt.Println(attr.Key + ":" + attr.Value) }
func (attr *AttrEmpty) GetKey() string                    { return attr.Key }
func (attr *AttrEmpty) GetValue() string                  { return attr.Value }
func (attr *AttrEmpty) GetKeyValuePair() (string, string) { return attr.Key, attr.Value }
func (attr *AttrEmpty) GetType() string                   { return attr.Type }

// ##==================================================================
type AttrAtParam struct {
	Key   string
	Value string
	Type  string
}

func NewAttrAtParam(key string, value string) (*AttrEmpty, error) {
	attr := &AttrEmpty{
		Key:   key,
		Value: value,
		Type:  KeyAttrAtParam,
	}
	return attr, nil
}

func (attr *AttrAtParam) Print()                            { fmt.Println(attr.Key + ":" + attr.Value) }
func (attr *AttrAtParam) GetKey() string                    { return attr.Key }
func (attr *AttrAtParam) GetValue() string                  { return attr.Value }
func (attr *AttrAtParam) GetKeyValuePair() (string, string) { return attr.Key, attr.Value }
func (attr *AttrAtParam) GetType() string                   { return attr.Type }

// ##==================================================================
type AttrStr struct {
	Key   string
	Value string
	Type  string
}

func NewAttrStr(key string, value string) (*AttrEmpty, error) {
	attr := &AttrEmpty{
		Key:   key,
		Value: value,
		Type:  KeyAttrStr,
	}
	return attr, nil
}

func (attr *AttrStr) Print()                            { fmt.Println(attr.Key + ":" + attr.Value) }
func (attr *AttrStr) GetKey() string                    { return attr.Key }
func (attr *AttrStr) GetValue() string                  { return attr.Value }
func (attr *AttrStr) GetKeyValuePair() (string, string) { return attr.Key, attr.Value }
func (attr *AttrStr) GetType() string                   { return attr.Type }

// ##==================================================================
type AttrBool struct {
	Key   string
	Value string
	Type  string
}

func NewAttrBool(key string, value string) (*AttrEmpty, error) {
	attr := &AttrEmpty{
		Key:   key,
		Value: value,
		Type:  KeyAttrBool,
	}
	return attr, nil
}

func (attr *AttrBool) Print()                            { fmt.Println(attr.Key + ":" + attr.Value) }
func (attr *AttrBool) GetKey() string                    { return attr.Key }
func (attr *AttrBool) GetValue() string                  { return attr.Value }
func (attr *AttrBool) GetKeyValuePair() (string, string) { return attr.Key, attr.Value }
func (attr *AttrBool) GetType() string                   { return attr.Type }

// ##==================================================================
type AttrInt struct {
	Key   string
	Value string
	Type  string
}

func NewAttrInt(key string, value string) (*AttrEmpty, error) {
	attr := &AttrEmpty{
		Key:   key,
		Value: value,
		Type:  KeyAttrInt,
	}
	return attr, nil
}

func (attr *AttrInt) Print()                            { fmt.Println(attr.Key + ":" + attr.Value) }
func (attr *AttrInt) GetKey() string                    { return attr.Key }
func (attr *AttrInt) GetValue() string                  { return attr.Value }
func (attr *AttrInt) GetKeyValuePair() (string, string) { return attr.Key, attr.Value }
func (attr *AttrInt) GetType() string                   { return attr.Type }
package gtml

import (
	"fmt"
	"os"
	"slices"
	"strings"

	"github.com/PuerkitoBio/goquery"
	"github.com/phillip-england/fungi"
	"github.com/phillip-england/gqpp"
	"github.com/phillip-england/purse"
)

// ##==================================================================
const (
	KeyElementComponent = "_component"
	KeyElementFor       = "_for"
	KeyElementIf        = "_if"
	KeyElementElse      = "_else"
)

// ##==================================================================
type Element interface {
	GetSelection() *goquery.Selection
	GetParam() (Param, error)
	SetHtml(htmlStr string)
	GetHtml() string
	Print()
	GetType() string
	GetAttr() string
	GetAttrParts() []string
	GetProps() []Prop
	GetCompNames() []string
	GetPlaceholders() []Placeholder
}

func GetFullElementList() []string {
	childElements := GetChildElementList()
	full := append(childElements, KeyElementComponent)
	return full
}

func GetChildElementList() []string {
	return []string{KeyElementFor, KeyElementIf, KeyElementElse}
}

func NewElement(sel *goquery.Selection, compNames []string) (Element, error) {
	match := gqpp.GetFirstMatchingAttr(sel, GetFullElementList()...)
	switch match {
	case KeyElementComponent:
		elm, err := NewElementComponent(sel, compNames)
		if err != nil {
			return nil, err
		}
		return elm, nil
	case KeyElementFor:
		elm, err := NewElementFor(sel, compNames)
		if err != nil {
			return nil, err
		}
		return elm, nil
	case KeyElementIf:
		elm, err := NewElementIf(sel, compNames)
		if err != nil {
			return nil, err
		}
		return elm, nil
	case KeyElementElse:
		elm, err := NewElementElse(sel, compNames)
		if err != nil {
			return nil, err
		}
		return elm, nil
	}
	htmlStr, err := gqpp.NewHtmlFromSelection(sel)
	if err != nil {
		return nil, err
	}
	return nil, fmt.Errorf("provided selection is not a valid element: %s", htmlStr)
}

func WalkElementChildren(elm Element, fn func(child Element) error) error {
	var potErr error
	elm.GetSelection().Find("*").Each(func(i int, inner *goquery.Selection) {
		child, err := NewElement(inner, elm.GetCompNames())
		if err != nil {
			// skip elements which are not a valid Element
		} else {
			err = fn(child)
			if err != nil {
				potErr = err
				return
			}
		}
	})
	if potErr != nil {
		return potErr
	}
	return nil
}

func WalkElementChildrenIncludingRoot(elm Element, fn func(child Element) error) error {
	err := fn(elm)
	if err != nil {
		return err
	}
	var potErr error
	elm.GetSelection().Find("*").Each(func(i int, inner *goquery.Selection) {
		child, err := NewElement(inner, elm.GetCompNames())
		if err != nil {
			// skip elements which are not a valid Element
		} else {
			err = fn(child)
			if err != nil {
				potErr = err
				return
			}
		}
	})
	if potErr != nil {
		return potErr
	}
	return nil
}

func GetElementParams(elm Element) ([]Param, error) {
	params := make([]Param, 0)
	elementSpecificParams := make([]Param, 0)
	err := WalkElementChildren(elm, func(child Element) error {
		param, err := child.GetParam()
		if err != nil {
			return err
		}
		if !slices.Contains(elementSpecificParams, param) && param != nil {
			elementSpecificParams = append(elementSpecificParams, param)
		}
		return nil
	})
	if err != nil {
		return params, err
	}
	strParams := make([]Param, 0)
	for _, prop := range elm.GetProps() {
		if prop.GetType() == KeyPropPlaceholder {
			val := prop.GetValue()
			openIndex := strings.Index(val, "(")
			val = val[openIndex+1:]
			val = purse.ReplaceLastInstanceOf(val, ")", "")
			val = purse.Squeeze(val)
			parts := strings.Split(val, ",")
			for _, part := range parts {
				if strings.Contains(part, "PARAM.") {
					part = strings.Replace(part, "PARAM.", "", 1)
					param, err := NewParam(part, "string")
					if err != nil {
						return params, err
					}
					if !slices.Contains(strParams, param) && purse.MustEqualOneOf(prop.GetType(), KeyPropForStr, KeyPropPlaceholder) {
						strParams = append(strParams, param)
					}
				}
			}
			continue
		}
		param, err := NewParam(prop.GetValue(), "string")
		if err != nil {
			return params, err
		}
		if !slices.Contains(strParams, param) && purse.MustEqualOneOf(prop.GetType(), KeyPropStr, KeyPropPlaceholder) {
			strParams = append(strParams, param)
		}
	}
	params = append(strParams, elementSpecificParams...)
	return params, nil
}

func WalkElementDirectChildren(elm Element, fn func(child Element) error) error {
	err := WalkElementChildren(elm, func(child Element) error {
		if !gqpp.HasParentWithAttrs(child.GetSelection(), elm.GetSelection(), GetChildElementList()...) {
			err := fn(child)
			if err != nil {
				return err
			}
		}
		return nil
	})
	if err != nil {
		return err
	}
	return nil
}

func WalkElementProps(elm Element, fn func(prop Prop) error) error {
	allProps := make([]Prop, 0)
	for _, prop := range elm.GetProps() {
		allProps = append(allProps, prop)
	}
	err := WalkElementChildren(elm, func(child Element) error {
		for _, prop := range child.GetProps() {
			allProps = append(allProps, prop)
		}
		return nil
	})
	if err != nil {
		return err
	}
	for _, prop := range allProps {
		err := fn(prop)
		if err != nil {
			return err
		}
	}
	return nil
}

func WalkElementPlaceholders(elm Element, fn func(placeholder Placeholder) error) error {
	allPlaceholders := make([]Placeholder, 0)
	for _, placeholder := range elm.GetPlaceholders() {
		allPlaceholders = append(allPlaceholders, placeholder)
	}
	err := WalkElementChildren(elm, func(child Element) error {
		for _, placeholder := range child.GetPlaceholders() {
			allPlaceholders = append(allPlaceholders, placeholder)
		}
		return nil
	})
	if err != nil {
		return err
	}
	for _, placeholder := range allPlaceholders {
		err := fn(placeholder)
		if err != nil {
			return err
		}
	}
	return nil
}

func GetElementHtmlWithoutChildren(elm Element) (string, error) {
	elmHtml := elm.GetHtml()
	err := WalkElementDirectChildren(elm, func(child Element) error {
		childHtml := child.GetHtml()
		elmHtml = strings.Replace(elmHtml, childHtml, "", 1)
		return nil
	})
	if err != nil {
		return "", err
	}
	return elmHtml, nil
}

func GetElementProps(elm Element) ([]Prop, error) {
	props := make([]Prop, 0)
	elmHtml := elm.GetHtml()
	err := WalkElementDirectChildren(elm, func(child Element) error {
		childHtml := child.GetHtml()
		elmHtml = strings.Replace(elmHtml, childHtml, "", 1)
		return nil
	})
	if err != nil {
		return props, err
	}
	strProps := purse.ScanBetweenSubStrs(elmHtml, "{{", "}}")
	for _, strProp := range strProps {
		prop, err := NewProp(strProp, elm.GetCompNames())
		if err != nil {
			return props, err
		}
		props = append(props, prop)
	}
	return props, nil
}

func GetElementVars(elm Element) ([]Var, error) {
	vars := make([]Var, 0)
	err := WalkElementDirectChildren(elm, func(child Element) error {
		innerVar, err := NewVar(child)
		if err != nil {
			return nil
		}
		vars = append(vars, innerVar)
		return nil
	})
	if err != nil {
		return nil, err
	}
	return vars, nil
}

func GetElementAsBuilderSeries(elm Element, builderName string) (string, error) {
	clay := elm.GetHtml()
	err := WalkElementDirectChildren(elm, func(child Element) error {
		childHtml := child.GetHtml()
		newVar, err := NewVar(child)
		if err != nil {
			return err
		}
		varType := newVar.GetType()
		if purse.MustEqualOneOf(varType, KeyVarGoElse, KeyVarGoFor, KeyVarGoIf) {
			call := fmt.Sprintf("%s.WriteString(%s)", builderName, newVar.GetVarName())
			clay = strings.Replace(clay, childHtml, call, 1)
		}
		return nil
	})
	if err != nil {
		return "", err
	}
	err = WalkElementProps(elm, func(prop Prop) error {
		if prop.GetType() == KeyPropPlaceholder {
			val := strings.ReplaceAll(prop.GetValue(), "PARAM.", "")
			call := fmt.Sprintf("%s.WriteString(%s)", builderName, val)
			clay = strings.Replace(clay, prop.GetRaw(), call, 1)
			return nil
		}
		call := fmt.Sprintf("%s.WriteString(%s)", builderName, prop.GetValue())
		clay = strings.Replace(clay, prop.GetRaw(), call, 1)
		return nil
	})
	if err != nil {
		return "", err
	}
	if strings.Index(clay, builderName) == -1 {
		singleCall := fmt.Sprintf("%s.WriteString(`%s`)", builderName, clay)
		return singleCall, nil
	}
	series := ""
	for {
		builderIndex := strings.Index(clay, builderName)
		if builderIndex == -1 {
			break
		}
		htmlPart := clay[:builderIndex]
		if htmlPart != "" {
			htmlCall := fmt.Sprintf("%s.WriteString(`%s`)", builderName, htmlPart)
			series += htmlCall + "\n"
			clay = strings.Replace(clay, htmlPart, "", 1)
		}
		endBuilderIndex := strings.Index(clay, ")")
		loopCount := 0
		for {
			loopCount++
			nextChar := string(clay[endBuilderIndex+loopCount])
			if nextChar == ")" {
				endBuilderIndex = endBuilderIndex + loopCount
				continue
			}
			break
		}
		builderPart := clay[:endBuilderIndex+1]
		series += builderPart + "\n"
		clay = strings.Replace(clay, builderPart, "", 1)
	}
	if len(clay) > 0 {
		htmlCall := fmt.Sprintf("%s.WriteString(`%s`)", builderName, clay)
		series += htmlCall + "\n"
	}
	return series, nil
}

func WalkAllElementNodes(elm Element, fn func(sel *goquery.Selection) error) error {
	var potErr error
	elm.GetSelection().Find("*").Each(func(i int, s *goquery.Selection) {
		err := fn(s)
		if err != nil {
			potErr = err
			return
		}
	})
	if potErr != nil {
		return potErr
	}
	return nil
}

func WalkAllElementNodesWithoutChildren(elm Element, fn func(sel *goquery.Selection) error) error {
	htmlNoChildren, err := GetElementHtmlWithoutChildren(elm)
	if err != nil {
		return err
	}
	sel, err := gqpp.NewSelectionFromStr(htmlNoChildren)
	if err != nil {
		return err
	}
	var potErr error
	sel.Find("*").Each(func(i int, s *goquery.Selection) {
		err := fn(s)
		if err != nil {
			potErr = err
			return
		}
	})
	if potErr != nil {
		return potErr
	}
	return nil
}

func GetElementPlaceholders(elm Element, compNames []string) ([]Placeholder, error) {
	placeholders := make([]Placeholder, 0)
	elmNodeName := goquery.NodeName(elm.GetSelection())
	for _, name := range compNames {
		if strings.ToLower(name) == elmNodeName {
			place, err := NewPlaceholder(elm.GetHtml(), name)
			if err != nil {
				return nil, err
			}
			placeholders = append(placeholders, place)
		}
		err := WalkAllElementNodesWithoutChildren(elm, func(sel *goquery.Selection) error {
			nodeName := goquery.NodeName(sel)
			nodeHtml, err := gqpp.NewHtmlFromSelection(sel)
			if err != nil {
				return err
			}
			if nodeName == strings.ToLower(name) {
				place, err := NewPlaceholder(nodeHtml, name)
				if err != nil {
					return err
				}
				placeholders = append(placeholders, place)
			}
			return nil
		})
		if err != nil {
			panic(err)
		}
	}
	return placeholders, nil
}

func ReadComponentElementsFromFile(path string, compNames []string) ([]Element, error) {
	elms := make([]Element, 0)
	f, err := os.ReadFile(path)
	if err != nil {
		return elms, err
	}
	fStr := string(f)
	doc, err := goquery.NewDocumentFromReader(strings.NewReader(fStr))
	if err != nil {
		return elms, err
	}
	var potErr error
	doc.Find("*").Each(func(i int, sel *goquery.Selection) {
		_, exists := sel.Attr(KeyElementComponent)
		if exists {
			elm, err := NewElement(sel, compNames)
			if err != nil {
				potErr = err
				return
			}
			elms = append(elms, elm)
		}
	})
	if potErr != nil {
		return elms, potErr
	}
	return elms, nil
}

func ReadComponentElementNamesFromFile(path string) ([]string, error) {
	names := make([]string, 0)
	f, err := os.ReadFile(path)
	if err != nil {
		return names, err
	}
	fStr := string(f)
	doc, err := goquery.NewDocumentFromReader(strings.NewReader(fStr))
	if err != nil {
		return names, err
	}
	doc.Find("*").Each(func(i int, sel *goquery.Selection) {
		compAttr, exists := sel.Attr(KeyElementComponent)
		if exists {
			names = append(names, compAttr)
		}
	})
	return names, nil
}

func ReplaceElementPlaceholders(elm Element) (Element, error) {
	elmHtml := elm.GetHtml()
	err := WalkElementPlaceholders(elm, func(placeholder Placeholder) error {
		elmHtml = strings.Replace(elmHtml, placeholder.GetHtml(), "{{ "+placeholder.GetFuncCall()+" }}", 1)
		return nil
	})
	newSel, err := gqpp.NewSelectionFromStr(elmHtml)
	if err != nil {
		return nil, err
	}
	newElm, err := NewElement(newSel, elm.GetCompNames())
	if err != nil {
		return nil, err
	}
	return newElm, nil
}

// ##==================================================================
type ElementComponent struct {
	Selection    *goquery.Selection
	Html         string
	Type         string
	Attr         string
	AttrParts    []string
	Name         string
	Props        []Prop
	Placeholders []Placeholder
	CompNames    []string
}

func NewElementComponent(sel *goquery.Selection, compNames []string) (*ElementComponent, error) {
	elm := &ElementComponent{
		CompNames: compNames,
	}
	err := fungi.Process(
		func() error { return elm.initSelection(sel) },
		func() error { return elm.initType() },
		func() error { return elm.initHtml() },
		func() error { return elm.initAttr() },
		func() error { return elm.initName() },
		func() error { return elm.initPlaceholders() },
		func() error { return elm.initProps() },
	)
	if err != nil {
		return nil, err
	}
	return elm, nil
}

func (elm *ElementComponent) GetSelection() *goquery.Selection { return elm.Selection }
func (elm *ElementComponent) GetParam() (Param, error) {
	return nil, nil
}
func (elm *ElementComponent) GetHtml() string                { return elm.Html }
func (elm *ElementComponent) SetHtml(htmlStr string)         { elm.Html = htmlStr }
func (elm *ElementComponent) Print()                         { fmt.Println(elm.Html) }
func (elm *ElementComponent) GetType() string                { return elm.Type }
func (elm *ElementComponent) GetAttr() string                { return elm.Attr }
func (elm *ElementComponent) GetAttrParts() []string         { return elm.AttrParts }
func (elm *ElementComponent) GetName() string                { return elm.Name }
func (elm *ElementComponent) GetProps() []Prop               { return elm.Props }
func (elm *ElementComponent) GetCompNames() []string         { return elm.CompNames }
func (elm *ElementComponent) GetPlaceholders() []Placeholder { return elm.Placeholders }

func (elm *ElementComponent) initSelection(sel *goquery.Selection) error {
	elm.Selection = sel
	return nil
}

func (elm *ElementComponent) initType() error {
	elm.Type = KeyElementComponent
	return nil
}

func (elm *ElementComponent) initHtml() error {
	htmlStr, err := gqpp.NewHtmlFromSelection(elm.GetSelection())
	if err != nil {
		return err
	}
	elm.Html = htmlStr
	return nil
}

func (elm *ElementComponent) initAttr() error {
	attr, err := gqpp.ForceElementAttr(elm.GetSelection(), KeyElementComponent)
	if err != nil {
		return err
	}
	parts, err := gqpp.ForceElementAttrParts(elm.GetSelection(), KeyElementComponent, 1)
	if err != nil {
		return err
	}
	elm.Attr = attr
	elm.AttrParts = parts
	return nil
}

func (elm *ElementComponent) initName() error {
	elm.Name = fmt.Sprintf("%s:%s", elm.GetType(), elm.GetAttr())
	return nil
}

func (elm *ElementComponent) initPlaceholders() error {
	placeholders, err := GetElementPlaceholders(elm, elm.CompNames)
	if err != nil {
		return err
	}
	elm.Placeholders = placeholders
	return nil
}

func (elm *ElementComponent) initProps() error {
	props, err := GetElementProps(elm)
	if err != nil {
		return err
	}
	elm.Props = props
	return nil
}

// ##==================================================================
type ElementFor struct {
	Selection    *goquery.Selection
	Html         string
	Type         string
	Attr         string
	AttrParts    []string
	Name         string
	Props        []Prop
	Placeholders []Placeholder
	CompNames    []string
}

func NewElementFor(sel *goquery.Selection, compNames []string) (*ElementFor, error) {
	elm := &ElementFor{
		CompNames: compNames,
	}
	err := fungi.Process(
		func() error { return elm.initSelection(sel) },
		func() error { return elm.initType() },
		func() error { return elm.initHtml() },
		func() error { return elm.initAttr() },
		func() error { return elm.initName() },
		func() error { return elm.initPlaceholders() },
		func() error { return elm.initProps() },
	)
	if err != nil {
		return nil, err
	}
	return elm, nil
}

func (elm *ElementFor) GetSelection() *goquery.Selection { return elm.Selection }
func (elm *ElementFor) GetParam() (Param, error) {
	parts := elm.GetAttrParts()
	iterItems := parts[2]
	if strings.Contains(iterItems, ".") {
		return nil, nil
	}
	iterType := parts[3]
	param, err := NewParam(iterItems, iterType)
	if err != nil {
		return nil, err
	}
	return param, nil
}
func (elm *ElementFor) GetHtml() string                { return elm.Html }
func (elm *ElementFor) SetHtml(htmlStr string)         { elm.Html = htmlStr }
func (elm *ElementFor) Print()                         { fmt.Println(elm.Html) }
func (elm *ElementFor) GetType() string                { return elm.Type }
func (elm *ElementFor) GetAttr() string                { return elm.Attr }
func (elm *ElementFor) GetAttrParts() []string         { return elm.AttrParts }
func (elm *ElementFor) GetName() string                { return elm.Name }
func (elm *ElementFor) GetProps() []Prop               { return elm.Props }
func (elm *ElementFor) GetCompNames() []string         { return elm.CompNames }
func (elm *ElementFor) GetPlaceholders() []Placeholder { return elm.Placeholders }

func (elm *ElementFor) initSelection(sel *goquery.Selection) error {
	elm.Selection = sel
	return nil
}

func (elm *ElementFor) initType() error {
	elm.Type = KeyElementFor
	return nil
}

func (elm *ElementFor) initHtml() error {
	htmlStr, err := gqpp.NewHtmlFromSelection(elm.GetSelection())
	if err != nil {
		return err
	}
	elm.Html = htmlStr
	return nil
}

func (elm *ElementFor) initAttr() error {
	attr, err := gqpp.ForceElementAttr(elm.GetSelection(), KeyElementFor)
	if err != nil {
		return err
	}
	parts, err := gqpp.ForceElementAttrParts(elm.GetSelection(), KeyElementFor, 4)
	if err != nil {
		return err
	}
	elm.Attr = attr
	elm.AttrParts = parts
	return nil
}

func (elm *ElementFor) initName() error {
	elm.Name = fmt.Sprintf("%s:%s", elm.GetType(), elm.GetAttr())
	return nil
}

func (elm *ElementFor) initPlaceholders() error {
	placeholders, err := GetElementPlaceholders(elm, elm.CompNames)
	if err != nil {
		return err
	}
	elm.Placeholders = placeholders
	return nil
}

func (elm *ElementFor) initProps() error {
	props, err := GetElementProps(elm)
	if err != nil {
		return err
	}
	elm.Props = props
	return nil
}

// ##==================================================================
type ElementIf struct {
	Selection    *goquery.Selection
	Html         string
	Type         string
	Attr         string
	AttrParts    []string
	Name         string
	Props        []Prop
	Placeholders []Placeholder
	CompNames    []string
}

func NewElementIf(sel *goquery.Selection, compNames []string) (*ElementIf, error) {
	elm := &ElementIf{
		CompNames: compNames,
	}
	err := fungi.Process(
		func() error { return elm.initSelection(sel) },
		func() error { return elm.initType() },
		func() error { return elm.initHtml() },
		func() error { return elm.initAttr() },
		func() error { return elm.initName() },
		func() error { return elm.initPlaceholders() },
		func() error { return elm.initProps() },
	)
	if err != nil {
		return nil, err
	}
	return elm, nil
}

func (elm *ElementIf) GetSelection() *goquery.Selection { return elm.Selection }
func (elm *ElementIf) GetParam() (Param, error) {
	param, err := NewParam(elm.Attr, "bool")
	if err != nil {
		return nil, err
	}
	return param, nil
}
func (elm *ElementIf) GetHtml() string                { return elm.Html }
func (elm *ElementIf) SetHtml(htmlStr string)         { elm.Html = htmlStr }
func (elm *ElementIf) Print()                         { fmt.Println(elm.Html) }
func (elm *ElementIf) GetType() string                { return elm.Type }
func (elm *ElementIf) GetAttr() string                { return elm.Attr }
func (elm *ElementIf) GetAttrParts() []string         { return elm.AttrParts }
func (elm *ElementIf) GetName() string                { return elm.Name }
func (elm *ElementIf) GetProps() []Prop               { return elm.Props }
func (elm *ElementIf) GetCompNames() []string         { return elm.CompNames }
func (elm *ElementIf) GetPlaceholders() []Placeholder { return elm.Placeholders }

func (elm *ElementIf) initSelection(sel *goquery.Selection) error {
	elm.Selection = sel
	return nil
}

func (elm *ElementIf) initType() error {
	elm.Type = KeyElementIf
	return nil
}

func (elm *ElementIf) initHtml() error {
	htmlStr, err := gqpp.NewHtmlFromSelection(elm.GetSelection())
	if err != nil {
		return err
	}
	elm.Html = htmlStr
	return nil
}

func (elm *ElementIf) initAttr() error {
	attr, err := gqpp.ForceElementAttr(elm.GetSelection(), KeyElementIf)
	if err != nil {
		return err
	}
	parts, err := gqpp.ForceElementAttrParts(elm.GetSelection(), KeyElementIf, 1)
	if err != nil {
		return err
	}
	elm.Attr = attr
	elm.AttrParts = parts
	return nil
}

func (elm *ElementIf) initName() error {
	elm.Name = fmt.Sprintf("%s:%s", elm.GetType(), elm.GetAttr())
	return nil
}

func (elm *ElementIf) initPlaceholders() error {
	placeholders, err := GetElementPlaceholders(elm, elm.CompNames)
	if err != nil {
		return err
	}
	elm.Placeholders = placeholders
	return nil
}

func (elm *ElementIf) initProps() error {
	props, err := GetElementProps(elm)
	if err != nil {
		return err
	}
	elm.Props = props
	return nil
}

// ##==================================================================
type ElementElse struct {
	Selection    *goquery.Selection
	Html         string
	Type         string
	Attr         string
	AttrParts    []string
	Name         string
	Props        []Prop
	Placeholders []Placeholder
	CompNames    []string
}

func NewElementElse(sel *goquery.Selection, compNames []string) (*ElementElse, error) {
	elm := &ElementElse{
		CompNames: compNames,
	}
	err := fungi.Process(
		func() error { return elm.initSelection(sel) },
		func() error { return elm.initType() },
		func() error { return elm.initHtml() },
		func() error { return elm.initAttr() },
		func() error { return elm.initName() },
		func() error { return elm.initPlaceholders() },
		func() error { return elm.initProps() },
	)
	if err != nil {
		return nil, err
	}
	return elm, nil
}

func (elm *ElementElse) GetSelection() *goquery.Selection { return elm.Selection }
func (elm *ElementElse) GetParam() (Param, error) {
	param, err := NewParam(elm.Attr, "bool")
	if err != nil {
		return nil, err
	}
	return param, nil
}
func (elm *ElementElse) GetHtml() string                { return elm.Html }
func (elm *ElementElse) SetHtml(htmlStr string)         { elm.Html = htmlStr }
func (elm *ElementElse) Print()                         { fmt.Println(elm.Html) }
func (elm *ElementElse) GetType() string                { return elm.Type }
func (elm *ElementElse) GetAttr() string                { return elm.Attr }
func (elm *ElementElse) GetAttrParts() []string         { return elm.AttrParts }
func (elm *ElementElse) GetName() string                { return elm.Name }
func (elm *ElementElse) GetProps() []Prop               { return elm.Props }
func (elm *ElementElse) GetCompNames() []string         { return elm.CompNames }
func (elm *ElementElse) GetPlaceholders() []Placeholder { return elm.Placeholders }

func (elm *ElementElse) initSelection(sel *goquery.Selection) error {
	elm.Selection = sel
	return nil
}

func (elm *ElementElse) initType() error {
	elm.Type = KeyElementElse
	return nil
}

func (elm *ElementElse) initHtml() error {
	htmlStr, err := gqpp.NewHtmlFromSelection(elm.GetSelection())
	if err != nil {
		return err
	}
	elm.Html = htmlStr
	return nil
}

func (elm *ElementElse) initAttr() error {
	attr, err := gqpp.ForceElementAttr(elm.GetSelection(), KeyElementElse)
	if err != nil {
		return err
	}
	parts, err := gqpp.ForceElementAttrParts(elm.GetSelection(), KeyElementElse, 1)
	if err != nil {
		return err
	}
	elm.Attr = attr
	elm.AttrParts = parts
	return nil
}

func (elm *ElementElse) initName() error {
	elm.Name = fmt.Sprintf("%s:%s", elm.GetType(), elm.GetAttr())
	return nil
}

func (elm *ElementElse) initPlaceholders() error {
	placeholders, err := GetElementPlaceholders(elm, elm.CompNames)
	if err != nil {
		return err
	}
	elm.Placeholders = placeholders
	return nil
}

func (elm *ElementElse) initProps() error {
	props, err := GetElementProps(elm)
	if err != nil {
		return err
	}
	elm.Props = props
	return nil
}

// ##==================================================================

// ##==================================================================

// ##==================================================================

// ##==================================================================

// ##==================================================================

// ##==================================================================
package gtml

import (
	"fmt"
	"go/format"
	"strings"

	"github.com/phillip-england/fungi"
	"github.com/phillip-england/gqpp"

	"github.com/phillip-england/purse"
)

// ##==================================================================
type Func interface {
	GetData() string
	SetData(str string)
	GetVars() []Var
	Print()
}

func NewFunc(elm Element) (Func, error) {
	if elm.GetType() == KeyElementComponent {
		fn, err := NewGoComponentFunc(elm)
		if err != nil {
			return nil, err
		}
		return fn, nil
	}
	return nil, fmt.Errorf("provided element does not corrospond to a valid GoFunc: %s", elm.GetHtml())
}

// ##==================================================================
type GoComponentFunc struct {
	Element  Element
	Vars     []Var
	Data     string
	VarStr   string
	Name     string
	ParamStr string
}

func NewGoComponentFunc(elm Element) (*GoComponentFunc, error) {
	fn := &GoComponentFunc{
		Element: elm,
	}
	err := fungi.Process(
		func() error { return fn.initName() },
		func() error { return fn.initVars() },
		func() error { return fn.initVarStr() },
		func() error { return fn.initParamStr() },
		func() error { return fn.initData() },
	)
	if err != nil {
		return nil, err
	}
	return fn, nil
}

func (fn *GoComponentFunc) GetData() string    { return fn.Data }
func (fn *GoComponentFunc) SetData(str string) { fn.Data = str }
func (fn *GoComponentFunc) GetVars() []Var     { return fn.Vars }
func (fn *GoComponentFunc) Print()             { fmt.Println(fn.GetData()) }

func (fn *GoComponentFunc) initName() error {
	compAttr, err := gqpp.ForceElementAttr(fn.Element.GetSelection(), KeyElementComponent)
	if err != nil {
		return err
	}
	fn.Name = compAttr
	return nil
}

func (fn *GoComponentFunc) initVars() error {
	err := WalkElementDirectChildren(fn.Element, func(child Element) error {
		goVar, err := NewVar(child)
		if err != nil {
			return err
		}
		fn.Vars = append(fn.Vars, goVar)
		return nil
	})
	if err != nil {
		return err
	}
	return nil
}

func (fn *GoComponentFunc) initVarStr() error {
	str := ""
	for _, v := range fn.Vars {
		data := v.GetData()
		str += data + "\n"
	}
	str = purse.PrefixLines(str, "\t")
	fn.VarStr = str
	return nil
}

func (fn *GoComponentFunc) initParamStr() error {
	params, err := GetElementParams(fn.Element)
	if err != nil {
		return err
	}
	paramStrs := make([]string, 0)
	for _, param := range params {
		paramStrs = append(paramStrs, param.GetStr())
	}
	fn.ParamStr = strings.Join(paramStrs, ",")
	return nil
}

func (fn *GoComponentFunc) initData() error {
	series, err := GetElementAsBuilderSeries(fn.Element, "builder")
	if err != nil {
		return err
	}
	series = purse.PrefixLines(series, "\t")
	data := purse.RemoveFirstLine(fmt.Sprintf(`
func %s(%s) string {
	var builder strings.Builder
%s
%s
	return builder.String()
}
	`, fn.Name, fn.ParamStr, fn.VarStr, series))
	code, err := format.Source([]byte(data))
	if err != nil {
		return err
	}
	data = string(code)
	data = purse.RemoveEmptyLines(data)
	fn.Data = data
	return nil
}
package gtml

import "fmt"

// ##==================================================================
type Param interface {
	GetStr() string
	GetName() string
	GetType() string
	Print()
}

func NewParam(name string, typeof string) (Param, error) {
	param := NewParamGoFunc(name, typeof)
	return param, nil
}

// ##==================================================================
type ParamGoFunc struct {
	Name string
	Type string
}

func NewParamGoFunc(name string, typeof string) *ParamGoFunc {
	return &ParamGoFunc{
		Name: name,
		Type: typeof,
	}
}

func (param *ParamGoFunc) GetStr() string  { return param.Name + " " + param.Type }
func (param *ParamGoFunc) GetName() string { return param.Name }
func (param *ParamGoFunc) GetType() string { return param.Type }
func (param *ParamGoFunc) Print()          { fmt.Println(param.GetStr()) }

// ##==================================================================

// ##==================================================================

// ##==================================================================

// ##==================================================================

// ##==================================================================

// ##==================================================================

// ##==================================================================
package gtml

import (
	"fmt"
	"strings"

	"github.com/PuerkitoBio/goquery"
	"github.com/phillip-england/fungi"
	"github.com/phillip-england/gqpp"
	"github.com/phillip-england/purse"
)

// ##==================================================================
type Placeholder interface {
	Print()
	GetHtml() string
	GetFuncCall() string
}

func NewPlaceholder(foundAsHtml string, name string) (Placeholder, error) {
	place, err := NewPlaceholderComponent(foundAsHtml, name)
	if err != nil {
		return nil, err
	}
	return place, nil
}

// ##==================================================================
type PlaceholderComponent struct {
	Name           string
	NodeName       string
	Html           string
	Attrs          []Attr
	FuncParamSlice []string
	FuncParamStr   string
	FuncCall       string
}

func NewPlaceholderComponent(foundAsHtml string, name string) (*PlaceholderComponent, error) {
	place := &PlaceholderComponent{
		Name: name,
	}
	err := fungi.Process(
		func() error { return place.initNodeName(foundAsHtml) },
		func() error { return place.initHtml(foundAsHtml) },
		func() error { return place.initAttrs() },
		func() error { return place.initFuncParamSlice() },
		func() error { return place.initComponentFuncCall() },
	)
	if err != nil {
		return nil, err
	}
	return place, nil
}

func (place *PlaceholderComponent) initNodeName(foundAsHtml string) error {
	sel, err := gqpp.NewSelectionFromStr(foundAsHtml)
	if err != nil {
		return err
	}
	nodeName := goquery.NodeName(sel)
	place.NodeName = nodeName
	return nil
}

func (place *PlaceholderComponent) initHtml(foundAsHtml string) error {
	place.Html = foundAsHtml
	return nil
}

func (place *PlaceholderComponent) initAttrs() error {
	sel, err := gqpp.NewSelectionFromStr(place.Html)
	if err != nil {
		return err
	}
	for _, node := range sel.Nodes {
		for _, attr := range node.Attr {
			attrType, err := NewAttr(attr.Key, attr.Val)
			if err != nil {
				return err
			}
			place.Attrs = append(place.Attrs, attrType)
		}
	}
	return nil
}

func (place *PlaceholderComponent) initFuncParamSlice() error {
	funcParamSlice := make([]string, 0)
	for _, attr := range place.Attrs {
		if attr.GetType() == KeyAttrEmpty {
			continue
		}
		if attr.GetType() == KeyAttrStr {
			funcParamSlice = append(funcParamSlice, `"`+attr.GetValue()+`"`)
			continue
		}
		if attr.GetType() == KeyAttrAtParam {
			val := attr.GetValue()[1:]
			funcParamSlice = append(funcParamSlice, val)
			continue
		}
		if attr.GetType() == KeyAttrPlaceholder {
			sqVal := purse.Squeeze(attr.GetValue())
			sqVal = strings.Replace(sqVal, "{{", "", 1)
			sqVal = strings.Replace(sqVal, "}}", "", 1)
			funcParamSlice = append(funcParamSlice, "PARAM."+sqVal)
			continue
		}
		funcParamSlice = append(funcParamSlice, attr.GetValue())
	}
	place.FuncParamSlice = funcParamSlice
	place.FuncParamStr = strings.Join(funcParamSlice, ", ")
	return nil
}

func (place *PlaceholderComponent) initComponentFuncCall() error {
	call := fmt.Sprintf("%s(%s)", place.Name, place.FuncParamStr)
	place.FuncCall = call
	return nil
}
func (place *PlaceholderComponent) Print()              { fmt.Println(place.Html) }
func (place *PlaceholderComponent) GetHtml() string     { return place.Html }
func (place *PlaceholderComponent) GetFuncCall() string { return place.FuncCall }

// ##==================================================================

// ##==================================================================

// ##==================================================================

// ##==================================================================

// ##==================================================================

// ##==================================================================
package gtml

import (
	"fmt"
	"strings"

	"github.com/phillip-england/purse"
)

// ##==================================================================
const (
	KeyPropForType     = "PROPFORTYPE"
	KeyPropForStr      = "PROPFORSTR"
	KeyPropStr         = "PROPSTR"
	KeyPropPlaceholder = "PROPPLACEHOLDER"
)

// ##==================================================================
type Prop interface {
	GetRaw() string
	GetValue() string
	GetType() string
	Print()
}

func NewProp(str string, compNames []string) (Prop, error) {
	val := purse.Squeeze(str)
	val = purse.RemoveAllSubStr(val, "{{", "}}")
	if val == "" {
		return nil, fmt.Errorf("empty prop tag provided: %s", str)
	}
	if strings.Contains(val, "(") && strings.Contains(val, ")") {
		openIndex := strings.Index(val, "(")
		potentialName := val[:openIndex]
		if purse.MustEqualOneOf(potentialName, compNames...) {
			prop, err := NewPropPaceholder(str, val)
			if err != nil {
				return nil, err
			}
			return prop, nil
		}
	}
	if len(val) > 1 && val[0] == '.' {
		val = strings.Replace(val, ".", "", 1)
		prop, err := NewPropForStr(str, val)
		if err != nil {
			return nil, err
		}
		return prop, nil
	}
	if strings.Count(val, ".") == 1 && len(strings.Split(val, ".")) == 2 {
		prop, err := NewPropForType(str, val)
		if err != nil {
			return nil, err
		}
		return prop, nil
	}
	prop, err := NewPropStr(str, val)
	if err != nil {
		return nil, err
	}
	return prop, nil
}

func PropAsWriteStringCall(prop Prop, builderName string) string {
	return fmt.Sprintf("%s.WriteString(%s)", builderName, prop.GetValue())
}

// ##==================================================================
type PropForType struct {
	Raw   string
	Value string
	Type  string
}

func NewPropForType(raw string, val string) (*PropForType, error) {
	prop := &PropForType{
		Raw:   raw,
		Value: val,
		Type:  KeyPropForType,
	}
	return prop, nil
}

func (prop *PropForType) GetRaw() string   { return prop.Raw }
func (prop *PropForType) GetValue() string { return prop.Value }
func (prop *PropForType) GetType() string  { return prop.Type }
func (prop *PropForType) Print() {
	fmt.Println(fmt.Sprintf("raw: %s\nvalue: %s\ntype: %s", prop.Raw, prop.Value, prop.Type))
}

// ##==================================================================
type PropForStr struct {
	Raw   string
	Value string
	Type  string
}

func NewPropForStr(raw string, val string) (*PropForStr, error) {
	prop := &PropForStr{
		Raw:   raw,
		Value: val,
		Type:  KeyPropForStr,
	}
	return prop, nil
}

func (prop *PropForStr) GetRaw() string   { return prop.Raw }
func (prop *PropForStr) GetValue() string { return prop.Value }
func (prop *PropForStr) GetType() string  { return prop.Type }
func (prop *PropForStr) Print() {
	fmt.Println(fmt.Sprintf("raw: %s\nvalue: %s\ntype: %s", prop.Raw, prop.Value, prop.Type))
}

// ##==================================================================
type PropStr struct {
	Raw   string
	Value string
	Type  string
}

func NewPropStr(raw string, val string) (*PropStr, error) {
	prop := &PropStr{
		Raw:   raw,
		Value: val,
		Type:  KeyPropStr,
	}
	return prop, nil
}

func (prop *PropStr) GetRaw() string   { return prop.Raw }
func (prop *PropStr) GetValue() string { return prop.Value }
func (prop *PropStr) GetType() string  { return prop.Type }
func (prop *PropStr) Print() {
	fmt.Println(fmt.Sprintf("raw: %s\nvalue: %s\ntype: %s", prop.Raw, prop.Value, prop.Type))
}

// ##==================================================================
type PropPlaceholder struct {
	Raw   string
	Value string
	Type  string
}

func NewPropPaceholder(raw string, val string) (*PropPlaceholder, error) {
	prop := &PropPlaceholder{
		Raw:   raw,
		Value: val,
		Type:  KeyPropPlaceholder,
	}
	return prop, nil
}

func (prop *PropPlaceholder) GetRaw() string   { return prop.Raw }
func (prop *PropPlaceholder) GetValue() string { return prop.Value }
func (prop *PropPlaceholder) GetType() string  { return prop.Type }
func (prop *PropPlaceholder) Print() {
	fmt.Println(fmt.Sprintf("raw: %s\nvalue: %s\ntype: %s", prop.Raw, prop.Value, prop.Type))
}

// ##==================================================================

// ##==================================================================

// ##==================================================================

// ##==================================================================

// ##==================================================================
package gtml

import (
	"fmt"

	"github.com/phillip-england/fungi"
	"github.com/phillip-england/purse"
)

// ##==================================================================
const (
	KeyVarGoFor  = "VARGOFOR"
	KeyVarGoIf   = "VARGOIF"
	KeyVarGoElse = "VARGOELSE"
)

// ##==================================================================
type Var interface {
	GetData() string
	GetVarName() string
	GetType() string
}

func NewVar(elm Element) (Var, error) {
	switch elm.GetType() {
	case KeyElementFor:
		v, err := NewVarGoFor(elm)
		if err != nil {
			return nil, err
		}
		return v, nil
	case KeyElementIf:
		v, err := NewVarGoIf(elm)
		if err != nil {
			return nil, err
		}
		return v, nil
	case KeyElementElse:
		v, err := NewVarGoElse(elm)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
	return nil, fmt.Errorf("element does not corrospond to a valid Var: %s", elm.GetHtml())
}

// ##==================================================================
type VarGoFor struct {
	Element       Element
	VarName       string
	BuilderName   string
	Vars          []Var
	WriteVarsAs   string
	Data          string
	IterItems     string
	IterItem      string
	IterType      string
	BuilderSeries string
	Type          string
}

func NewVarGoFor(elm Element) (*VarGoFor, error) {
	v := &VarGoFor{
		Element: elm,
	}
	err := fungi.Process(
		func() error { return v.initBasicInfo() },
		func() error { return v.initVars() },
		func() error { return v.initWriteVarsAs() },
		func() error { return v.initBuilderSeries() },
		func() error { return v.initData() },
	)
	if err != nil {
		return nil, err
	}
	return v, nil
}

func (v *VarGoFor) GetData() string    { return v.Data }
func (v *VarGoFor) GetVarName() string { return v.VarName }
func (v *VarGoFor) GetType() string    { return v.Type }

func (v *VarGoFor) initVarName() error {
	v.VarName = v.Element.GetAttrParts()[0]
	return nil
}

func (v *VarGoFor) initBasicInfo() error {
	attrParts := v.Element.GetAttrParts()
	v.VarName = attrParts[0] + "For"
	v.BuilderName = attrParts[0] + "Builder"
	v.IterItems = attrParts[2]
	v.IterItem = attrParts[0]
	v.IterType = purse.RemoveAllSubStr(attrParts[3], "[]")
	v.Type = KeyVarGoFor
	return nil
}

func (v *VarGoFor) initVars() error {
	vars, err := GetElementVars(v.Element)
	if err != nil {
		return err
	}
	v.Vars = vars
	return nil
}

func (v *VarGoFor) initWriteVarsAs() error {
	varsToWrite := ""
	for _, inner := range v.Vars {
		varsToWrite += "\t" + inner.GetData()
	}
	v.WriteVarsAs = varsToWrite
	return nil
}

func (v *VarGoFor) initBuilderSeries() error {
	series, err := GetElementAsBuilderSeries(v.Element, v.BuilderName)
	if err != nil {
		return err
	}
	v.BuilderSeries = series
	return nil
}

func (v *VarGoFor) initData() error {
	v.Data = purse.RemoveFirstLine(fmt.Sprintf(`
%s := gtmlFor(%s, func(i int, %s %s) string {
	var %s strings.Builder
%s
%s
	return %s.String()
})`, v.VarName, v.IterItems, v.IterItem, v.IterType, v.BuilderName, v.WriteVarsAs, v.BuilderSeries, v.BuilderName))
	v.Data = purse.RemoveEmptyLines(v.Data)
	return nil
}

// ##==================================================================
type VarGoIf struct {
	Element       Element
	VarName       string
	BuilderName   string
	Vars          []Var
	WriteVarsAs   string
	Data          string
	BuilderSeries string
	BoolToCheck   string
	Type          string
}

func NewVarGoIf(elm Element) (*VarGoIf, error) {
	v := &VarGoIf{
		Element: elm,
	}
	err := fungi.Process(
		func() error { return v.initBasicInfo() },
		func() error { return v.initVars() },
		func() error { return v.initWriteVarsAs() },
		func() error { return v.initBuilderSeries() },
		func() error { return v.initData() },
	)
	if err != nil {
		return nil, err
	}
	return v, nil
}

func (v *VarGoIf) GetData() string    { return v.Data }
func (v *VarGoIf) GetVarName() string { return v.VarName }
func (v *VarGoIf) GetType() string    { return v.Type }

func (v *VarGoIf) initBasicInfo() error {
	attr := v.Element.GetAttr()
	v.VarName = attr + "If"
	v.BuilderName = attr + "Builder"
	v.BoolToCheck = attr
	v.Type = KeyVarGoIf
	return nil
}

func (v *VarGoIf) initVars() error {
	vars, err := GetElementVars(v.Element)
	if err != nil {
		return err
	}
	v.Vars = vars
	return nil
}

func (v *VarGoIf) initWriteVarsAs() error {
	varsToWrite := ""
	for _, inner := range v.Vars {
		varsToWrite += "\t" + inner.GetData()
	}
	v.WriteVarsAs = varsToWrite
	return nil
}

func (v *VarGoIf) initBuilderSeries() error {
	series, err := GetElementAsBuilderSeries(v.Element, v.BuilderName)
	if err != nil {
		return err
	}
	v.BuilderSeries = series
	return nil
}

func (v *VarGoIf) initData() error {
	v.Data = purse.RemoveFirstLine(fmt.Sprintf(`
%s := gtmlIf(%s, func() string {
	var %s strings.Builder
%s
%s
	if %s {
		return %s.String()
	}
	return ""
})`, v.VarName, v.BoolToCheck, v.BuilderName, v.WriteVarsAs, v.BuilderSeries, v.BoolToCheck, v.BuilderName))
	v.Data = purse.RemoveEmptyLines(v.Data)
	return nil
}

// ##==================================================================
type VarGoElse struct {
	Element       Element
	VarName       string
	BuilderName   string
	Vars          []Var
	WriteVarsAs   string
	Data          string
	BuilderSeries string
	BoolToCheck   string
	Type          string
}

func NewVarGoElse(elm Element) (*VarGoElse, error) {
	v := &VarGoElse{
		Element: elm,
	}
	err := fungi.Process(
		func() error { return v.initBasicInfo() },
		func() error { return v.initVars() },
		func() error { return v.initWriteVarsAs() },
		func() error { return v.initBuilderSeries() },
		func() error { return v.initData() },
	)
	if err != nil {
		return nil, err
	}
	return v, nil
}

func (v *VarGoElse) GetData() string    { return v.Data }
func (v *VarGoElse) GetVarName() string { return v.VarName }
func (v *VarGoElse) GetType() string    { return v.Type }

func (v *VarGoElse) initBasicInfo() error {
	attr := v.Element.GetAttr()
	v.VarName = attr + "Else"
	v.BuilderName = attr + "Builder"
	v.BoolToCheck = attr
	v.Type = KeyVarGoElse
	return nil
}

func (v *VarGoElse) initVars() error {
	vars, err := GetElementVars(v.Element)
	if err != nil {
		return err
	}
	v.Vars = vars
	return nil
}

func (v *VarGoElse) initWriteVarsAs() error {
	varsToWrite := ""
	for _, inner := range v.Vars {
		varsToWrite += "\t" + inner.GetData()
	}
	v.WriteVarsAs = varsToWrite
	return nil
}

func (v *VarGoElse) initBuilderSeries() error {
	series, err := GetElementAsBuilderSeries(v.Element, v.BuilderName)
	if err != nil {
		return err
	}
	v.BuilderSeries = series
	return nil
}

func (v *VarGoElse) initData() error {
	v.Data = purse.RemoveFirstLine(fmt.Sprintf(`
%s := gtmlElse(%s, func() string {
	var %s strings.Builder
%s
%s
	if !%s {
		return %s.String()
	}
	return ""
})`, v.VarName, v.BoolToCheck, v.BuilderName, v.WriteVarsAs, v.BuilderSeries, v.BoolToCheck, v.BuilderName))
	v.Data = purse.RemoveEmptyLines(v.Data)
	return nil
}

// ##==================================================================

// ##==================================================================

// ##==================================================================
